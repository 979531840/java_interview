# Java基础

### 1、Java的四个基本特征（抽象、封装、继承、多态），对多态的理解。以及项目中哪里用到了多态。

* 抽象-就是把客观事物抽象出来。一般称为类或者接口。分为两部分，一种是数据抽象，就是对象的属性。另一种是过程的抽象，就是对象的行为特征。比如鸟这样一个类，属性可以抽象为翅膀、脚、羽毛等。过程抽象例如鸟飞，鸟叫等。

* 封装-封装是面向对象的核心思维。把对象的属性和行为封装起来。客观的事务封装成抽象的类。例如鸟类抽象成数据和过程后，把两个封装起来为一个对象。

* 继承-描述类与类之间的关系，允许和鼓励类的重用。继承是为了重用父类的代码，为实现多态性做准备。

* 多态-同一个事件发生在不同的对象上会产生不同的结果。实现多态的技术称为 `动态绑定`。多态的作用：`消除类型之间的耦合关系`。

举例子：老师和同学分别登录教务系统，但是进入的页面是不一样的。他们有相同的方法Login，但是登录的时候有不同的操作。两种角色继承了父类的方法，但是都有具体的实现。

* 多态存在的三个必要条件
	* 一、要有继承
	* 二、要有重写
	* 三、父类引用指向子类对象

* 多态实现的两种方式
	* 重载(Overload) 实现的是编译时的多态性（前绑定）
	* 重写(Override)  实现的是运行时的多态性（后绑定）

* 重载（Overload）和重写（Override）的区别： 
	* 重载就是同一个类中，有多个方法名相同，但参数列表不同（包括参数个数和参数类型），与返回值无关，与权限修饰符也无关。调用重载的方法时通过传递给它们不同的参数个数和参数类型来决定具体使用哪个方法。 
	* 重写就是子类重写基类（父类）的方法，方法名，参数列表和返回值都必须相同，否则就不是重写而是重载。权限修饰符不能小于被重写方法的修饰符。重写方法不能抛出新的异常或者是比被重写方法声明更加宽泛的检查型异常。

* 方法的重写Override要遵循“两同两小一大”规则：
	* 一、“两同”即方法名相同，形参列表相同
	* 二、“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等
	* 三、“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等

		注：构造方法不受以上规则约束。

* 方法的重载Overload要注意以下的几点：
	* 一、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序
	* 二、不能通过访问权限、返回类型和抛出异常的差异进行重载
	* 三、方法的异常类型和数目不会对重载造成影响

* 重载（Overload）：只要方法名一致，其他（参数列表、返回值）怎么折腾随便。

* 重写（Overriding）：只有实现的功能代码不一致，其他的（函数名、参数列表、返回值类型）必须都一致。

### 2、Java中的数据类型分类。

* 基本数据类型（或叫做原生类、内置类型）8种：
* 整数：byte，short，int，long（默认是int类型）
* 浮点类型： float，double（默认是double类型）
* 字符类型：char
* 布尔类型：boolean

* 引用数据类型3种：数组，类，接口
* 其中，基本数据类型之间除了boolean，其他数据类型之间可以任意的相互转换

* byte的取值范围为-128~127，占用1个字节（-2的7次方到2的7次方-1）
* short的取值范围为-32768~32767，占用2个字节（-2的15次方到2的15次方-1）
* int的取值范围为（-2147483648~2147483647），占用4个字节（-2的31次方到2的31次方-1）
* long的取值范围为（-9223372036854774808~9223372036854774807），占用8个字节（-2的63次方到2的63次方-1）
* 浮点型 float和double是表示浮点型的数据类型，他们之间的区别在于他们的精确度不同 float 3.402823e+38~ 1.401298e-45（e+38表示是乘以10的38次方，同样，e-45表示乘以10的负45次方）占用4个字节 double 1.797693e+308~4.9000000e-324 占用8个字节 double型比float型存储范围更大，精度更高
* char型（文本型） 用于存放字符的数据类型，占用2个字节，采用unicode编码，它的前128字节编码与ASCII兼容 字符的存储范围在\u0000~\uFFFF

### 3、面向过程和面向对象的区别。
	面向过程 是一件事 `怎么做` 具体到细节
	面向对象 是一件事 `谁来做` `谁`就是对象 他怎么做我不关心
* 例如 对于人吃东西来说 用面向过程 就是人 张开嘴 然后把东西放到嘴里 然后合上嘴 然后咀嚼 然后再挖一勺 用面向对象 就是 人 他有一个方法叫吃 至于怎么吃 细节实现 我不管 我直接调用就好

### 4、面向对象开发的（OOP）六个基本原则（单一指责、开放封闭、里氏替换、依赖倒置、合成聚合复用、接口隔离），迪米特法则。在项目中用过哪些原则。
* 六个基本原则
	* 单一指责 
		* 定义：一个类只负责一项职责。（高内聚、低耦合）
		* 一、可以降低类的复杂度。一个类只负责一项职责，逻辑简单。
		* 二、可以提高类的可读性，提高系统可维护性。
		* 三、降低变更引起的风险。
	* 开放封闭（开闭原则）
		* 定义：一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。
	* 里氏替换
		* 定义：子类可以扩展父类的功能，但不能改变父类原有的功能。尽量不要重写父类的方法，也尽量不要重载父类的方法。
	* 依赖倒置
		* 定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。
	* 迪米特法则
		* 定义：一个对象应该对其他对象保持最少的了解。尽量降低类与类之间的耦合。（不要与陌生人说话）
	* 接口隔离
		* 定义：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。
	* 合成聚合复用
		* 定义：要尽量使用合成和聚合，尽量不要使用继承。就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分，新对象通过向这些对象的委派达到复用已有功能的目的。

* 抽象、单一职责、高内聚、低耦合

### 5、static和final的区别和用途。
* static：表示静态或者全局，可以修饰属性、方法、代码块，静态属性和静态方法是属于类的（也可以说是属于类的所有对象的），可以用类名.静态属性/静态方法来访问，用static修饰的代码块是静态代码块，当虚拟机（JVM）加载该类时，就会执行静态代码块。 
* 修饰属性：当static修饰属性时，该属性称为静态变量或者类变量，该变量是在JVM加载类时初始化的；不被static修饰的属性是实例变量，在创建对象时被初始化，实例变量是各个对象独有的。使用一个类的静态变量并不会触发该类的加载。
* 修饰方法：被static修饰的方法称为类方法或者静态方法，一般通过类名调用。静态方法中不能使用this、super关键字，也不能访问实例变量和实例方法，只能访问静态变量和静态方法。父子类中，静态方法只能被静态方法覆盖，非静态方法只能被非静态方法覆盖。
* 修饰代码块：被static修饰的代码块被称为静态代码块，和代码块和属性以及方法是同一个等级的成员，可以有多个，位置可以随便放。JVM加载类时会执行这些静态代码块，如果static代码块有多个，JVM将按照它们在类中出现的先后顺序依次执行它们，每个代码块只会被执行一次。

* final：表示常量、最终，final可以修饰变量、方法、类。final修饰的局部变量为常量，一旦赋值不能修改。final修饰的成员变量必须在声明时赋值，或者在构造函数中，或者在代码块中赋初值，一旦赋值不能更改。final方法不能被子类重写。final类不能被继承，没有子类，final类中的方法默认是final的。final不能修饰构造方法。java中的String、Math等类就是final的。 
* 修饰变量：final修饰的局部变量为常量，一旦赋值不能修改。final修饰的成员变量必须在声明时赋值，或者在构造函数中，或者在代码块中赋初值，一旦赋值不能更改。如果final修饰的是对象引用，则引用不可变，引用的对象可以改变。
* 修饰方法：final修饰的方法不能被子类重写。
* 修饰类：final修饰的类不能被继承。

### 6、String、StringBuffer、StringBuilder的区别？对String不变性的理解。
* 都是final类，不能被继承。
* String 字符串常量。长度不可变。String final char[]。
* StringBuffer 字符串变量（线程安全）（synchronized）长度可变。
* StringBuilder 字符串变量（非线程安全）。长度可变。

* 对于String不变性的理解
	* String不能被继承。
	* String的+号链接可以创建新的字符串。
	* String a = new String("hahah")；可能会创建两个对象可能创建一个。如果常量池没有的话会在常量池创建一个新的对象。
	* Java的+号，底层使用StringBuilder的append来实现的。


### 7、String有重写Object的hashcode和toString方法吗？如果重新equals不重写hashcode会出现什么问题？

* Object的toString方法源码如下：

```
public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

* String的toString方法源码如下：
```
public String toString() {
    return this;
}
```


* 两个都需要重写。因为要满足以下三个条件。
	* 两个String，equals方法返回true，hashcode方法一定是true。
	* 两个String，equals方法返回false，hashcode方法一定是false。
	* 两个String，hashcode方法返回false，equals方法不一定是false。

* 如果不重写hashcode方法会出现什么问题？
	* 在存储hashMap的时候，如果原对象equals新对象，但是hashCode没有重写。则两个对象拥有了不同的hashCode，会在集合中存储两个值相同的对象，导致混淆。所以两个必须同时重写。
### 8、Java如何序列化，如何实现序列化和反序列化，常见的序列化协议有哪些？
* Java序列化定义
	* 将那些实现了Serializable接口的对象转换成一个字节序列，并能在以后将这个字节序列完全恢复成原来的对象，序列化可以弥补操作系统之间的差异。

* 如何实现序列化和反序列化
	* 实现序列化
	* 1、实现java.io.Serializable接口，就可实现序列化。
	* 2、通过ObjectOutputStream和ObjectInputStream就可以对对象进行序列化和反序列化。
	* 3、虚拟机是否允许反序列化，取决于（private static final long serialVersionUID）
	* 4、序列化不保存静态变量
	* 5、要想将父类对象也序列化，就需要让父类也实现Serializable 接口。
	* 6、Transient 关键字控制变量的序列化。在变量名上加该关键字，可以阻止该变量序列化到文件，反序列化后，变量设为初始值，int为0，对象为null。

	* `在序列化过程中，如果被序列化的类中定义了writeObject 和 readObject 方法，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化。`

* 常见的序列化协议：XML，JSON。

### 9、常见异常分为哪两种？常见异常的基类以及常见的异常？

* Java中有两种异常：受检查的异常(checked)和不受检查的异常(unchecked)。
	* 不受检查的异常不需要在方法或者构造函数上声明，就算方法或者构造函数的声明可能会抛出这样的异常。 
	* 受检查的异常必须要用throws抛出异常。

	![图片](http://img.blog.csdn.net/20140825105709593?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHVodWlfY3M=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)


常见的异常，NullPointerException,ClassNotFoundException,FileNotFoundException,ArrayIndexOutOfBoundsException 

### 10、Java中的NIO、BIO、AIO分别是什么？
* 网络编程的基本模型是C/S模型，即两个进程间的通信。
	* 传统的同步阻塞模型开发中，ServerSocket负责绑定IP地址，启动监听端口；Socket负责发起连接操作。连接成功后，双方通过输入和输出流进行同步阻塞式通信。 
	* 简单的描述一下BIO的服务端通信模型：采用BIO通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理没处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答通宵模型。
	* 为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程（需要了解更多请参考前面提供的文章），实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为"伪异步I/O模型"。


*  NIO我们一般认为是New I/O（也是官方的叫法），因为它是相对于老的I/O类库新增的（其实在JDK 1.4中就已经被引入了，但这个名词还会继续用很久，即使它们在现在看来已经是“旧”的了，所以也提示我们在命名时，需要好好考虑），做了很大的改变。但民间跟多人称之为Non-block I/O，即非阻塞I/O，因为这样叫，更能体现它的特点。而下文中的NIO，不是指整个新的I/O库，而是非阻塞I/O。

    * NIO提供了与传统BIO模型中的Socket和ServerSocket相对应的SocketChannel和ServerSocketChannel两种不同的套接字通道实现。

    新增的着两种通道都支持阻塞和非阻塞两种模式。

    阻塞模式使用就像传统中的支持一样，比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。

    对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用NIO的非阻塞模式来开发。


    *  Buffer是一个对象，包含一些要写入或者读出的数据。

    在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，它是直接读到缓冲区中的；在写入数据时，也是写入到缓冲区中。任何时候访问NIO中的数据，都是通过缓冲区进行操作。

    缓冲区实际上是一个数组，并提供了对数据结构化访问以及维护读写位置等信息。

    具体的缓存区有这些：ByteBuffe、CharBuffer、 ShortBuffer、IntBuffer、LongBuffer、FloatBuffer、DoubleBuffer。他们实现了相同的接口：Buffer。


    * 我们对数据的读取和写入要通过Channel，它就像水管一样，是一个通道。通道不同于流的地方就是通道是双向的，可以用于读、写和同时读写操作。

    底层的操作系统的通道一般都是全双工的，所以全双工的Channel比流能更好的映射底层操作系统的API。

    Channel主要分两大类：

    SelectableChannel：用户网络读写
    FileChannel：用于文件操作


    * Selector是Java  NIO 编程的基础。

    Selector提供选择已经就绪的任务的能力：Selector会不断轮询注册在其上的Channel，如果某个Channel上面发生读或者写事件，这个Channel就处于就绪状态，会被Selector轮询出来，然后通过SelectionKey可以获取就绪Channel的集合，进行后续的I/O操作。

    一个Selector可以同时轮询多个Channel，因为JDK使用了epoll()代替传统的select实现，所以没有最大连接句柄1024/2048的限制。所以，只需要一个线程负责Selector的轮询，就可以接入成千上万的客户端。

* AIO
	*  NIO 2.0引入了新的异步通道的概念，并提供了异步文件通道和异步套接字通道的实现。
	* 异步的套接字通道时真正的异步非阻塞I/O，对应于UNIX网络编程中的事件驱动I/O（AIO）。他不需要过多的Selector对注册的通道进行轮询即可实现异步读写，从而简化了NIO的编程模型。


* 同步阻塞IO（JAVA BIO）： 
    同步并阻塞，服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 

* 同步非阻塞IO(Java NIO) ： 
	同步非阻塞，服务器实现模式为一个请求一个线程，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。用户进程也需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问。 

* 异步阻塞IO（Java NIO）：  
   此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！  


* （Java AIO(NIO.2)）异步非阻塞IO:  
   在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。    

### 11、什么是匿名内部类？如何访问在其外面定义的变量？

### 12、Servlet的生存周期。

### 13、Jsp和Servlet的区别？

### 14、你知道的开源协议有哪些？

### 15、你知道的开源软件有哪些？

### 16、对于高负载、高并发、分布式、消息队列的了解。

### 17、object类你知道的方法。

### 18、Java的finalize，finally，final三个关键字的区别和应用场景。

### 19、Tomcat服务器的原理。

### 20、动态代理的实现方式和区别。

### 21、怎么实现负载均衡。

### 22、Select，poll，epoll的区别。